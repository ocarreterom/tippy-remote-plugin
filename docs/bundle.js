(function () {
  'use strict'

  /** !
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined'

  var timeoutDuration = (function () {
    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox']

    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        return 1
      }
    }

    return 0
  }())

  function microtaskDebounce (fn) {
    var called = false
    return function () {
      if (called) {
        return
      }

      called = true
      window.Promise.resolve().then(function () {
        called = false
        fn()
      })
    }
  }

  function taskDebounce (fn) {
    var scheduled = false
    return function () {
      if (!scheduled) {
        scheduled = true
        setTimeout(function () {
          scheduled = false
          fn()
        }, timeoutDuration)
      }
    }
  }

  var supportsMicroTasks = isBrowser && window.Promise
  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */

  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce
  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */

  function isFunction (functionToCheck) {
    var getType = {}
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]'
  }
  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */

  function getStyleComputedProperty (element, property) {
    if (element.nodeType !== 1) {
      return []
    } // NOTE: 1 DOM access here

    var window = element.ownerDocument.defaultView
    var css = window.getComputedStyle(element, null)
    return property ? css[property] : css
  }
  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */

  function getParentNode (element) {
    if (element.nodeName === 'HTML') {
      return element
    }

    return element.parentNode || element.host
  }
  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */

  function getScrollParent (element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body

      case '#document':
        return element.body
    } // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element)
    var overflow = _getStyleComputedProp.overflow
    var overflowX = _getStyleComputedProp.overflowX
    var overflowY = _getStyleComputedProp.overflowY

    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element
    }

    return getScrollParent(getParentNode(element))
  }
  /**
   * Returns the reference node of the reference object, or the reference object itself.
   * @method
   * @memberof Popper.Utils
   * @param {Element|Object} reference - the reference element (the popper will be relative to this)
   * @returns {Element} parent
   */

  function getReferenceNode (reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference
  }

  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode)
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent)
  /**
   * Determines if the browser is Internet Explorer
   * @method
   * @memberof Popper.Utils
   * @param {Number} version to check
   * @returns {Boolean} isIE
   */

  function isIE (version) {
    if (version === 11) {
      return isIE11
    }

    if (version === 10) {
      return isIE10
    }

    return isIE11 || isIE10
  }
  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */

  function getOffsetParent (element) {
    if (!element) {
      return document.documentElement
    }

    var noOffsetParent = isIE(10) ? document.body : null // NOTE: 1 DOM access here

    var offsetParent = element.offsetParent || null // Skip hidden elements which don't have an offsetParent

    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent
    }

    var nodeName = offsetParent && offsetParent.nodeName

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      return element ? element.ownerDocument.documentElement : document.documentElement
    } // .offsetParent will return the closest TH, TD or TABLE in case
    // no offsetParent is present, I hate this job...

    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent)
    }

    return offsetParent
  }

  function isOffsetContainer (element) {
    var nodeName = element.nodeName

    if (nodeName === 'BODY') {
      return false
    }

    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element
  }
  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */

  function getRoot (node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode)
    }

    return node
  }
  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */

  function findCommonOffsetParent (element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement
    } // Here we make sure to give as "start" the element that comes first in the DOM

    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING
    var start = order ? element1 : element2
    var end = order ? element2 : element1 // Get common ancestor container

    var range = document.createRange()
    range.setStart(start, 0)
    range.setEnd(end, 0)
    var commonAncestorContainer = range.commonAncestorContainer // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer
      }

      return getOffsetParent(commonAncestorContainer)
    } // one of the nodes is inside shadowDOM, find which one

    var element1root = getRoot(element1)

    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2)
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host)
    }
  }
  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */

  function getScroll (element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top'
    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft'
    var nodeName = element.nodeName

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement
      var scrollingElement = element.ownerDocument.scrollingElement || html
      return scrollingElement[upperSide]
    }

    return element[upperSide]
  }
  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */

  function includeScroll (rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false
    var scrollTop = getScroll(element, 'top')
    var scrollLeft = getScroll(element, 'left')
    var modifier = subtract ? -1 : 1
    rect.top += scrollTop * modifier
    rect.bottom += scrollTop * modifier
    rect.left += scrollLeft * modifier
    rect.right += scrollLeft * modifier
    return rect
  }
  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize (styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top'
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom'
    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width'])
  }

  function getSize (axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0)
  }

  function getWindowSizes (document) {
    var body = document.body
    var html = document.documentElement
    var computedStyle = isIE(10) && getComputedStyle(html)
    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    }
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function')
    }
  }

  var createClass = (function () {
    function defineProperties (target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i]
        descriptor.enumerable = descriptor.enumerable || false
        descriptor.configurable = true
        if ('value' in descriptor) descriptor.writable = true
        Object.defineProperty(target, descriptor.key, descriptor)
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps)
      if (staticProps) defineProperties(Constructor, staticProps)
      return Constructor
    }
  }())

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      })
    } else {
      obj[key] = value
    }

    return obj
  }

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i]

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key]
        }
      }
    }

    return target
  }
  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */

  function getClientRect (offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    })
  }
  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */

  function getBoundingClientRect (element) {
    var rect = {} // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11

    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect()
        var scrollTop = getScroll(element, 'top')
        var scrollLeft = getScroll(element, 'left')
        rect.top += scrollTop
        rect.left += scrollLeft
        rect.bottom += scrollTop
        rect.right += scrollLeft
      } else {
        rect = element.getBoundingClientRect()
      }
    } catch (e) {}

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    } // subtract scrollbar size from sizes

    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {}
    var width = sizes.width || element.clientWidth || result.width
    var height = sizes.height || element.clientHeight || result.height
    var horizScrollbar = element.offsetWidth - width
    var vertScrollbar = element.offsetHeight - height // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons

    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element)
      horizScrollbar -= getBordersSize(styles, 'x')
      vertScrollbar -= getBordersSize(styles, 'y')
      result.width -= horizScrollbar
      result.height -= vertScrollbar
    }

    return getClientRect(result)
  }

  function getOffsetRectRelativeToArbitraryNode (children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false
    var isIE10 = isIE(10)
    var isHTML = parent.nodeName === 'HTML'
    var childrenRect = getBoundingClientRect(children)
    var parentRect = getBoundingClientRect(parent)
    var scrollParent = getScrollParent(children)
    var styles = getStyleComputedProperty(parent)
    var borderTopWidth = parseFloat(styles.borderTopWidth)
    var borderLeftWidth = parseFloat(styles.borderLeftWidth) // In cases where the parent is fixed, we must ignore negative scroll in offset calc

    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0)
      parentRect.left = Math.max(parentRect.left, 0)
    }

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    })
    offsets.marginTop = 0
    offsets.marginLeft = 0 // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.

    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop)
      var marginLeft = parseFloat(styles.marginLeft)
      offsets.top -= borderTopWidth - marginTop
      offsets.bottom -= borderTopWidth - marginTop
      offsets.left -= borderLeftWidth - marginLeft
      offsets.right -= borderLeftWidth - marginLeft // Attach marginTop and marginLeft because in some circumstances we may need them

      offsets.marginTop = marginTop
      offsets.marginLeft = marginLeft
    }

    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent)
    }

    return offsets
  }

  function getViewportOffsetRectRelativeToArtbitraryNode (element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false
    var html = element.ownerDocument.documentElement
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html)
    var width = Math.max(html.clientWidth, window.innerWidth || 0)
    var height = Math.max(html.clientHeight, window.innerHeight || 0)
    var scrollTop = !excludeScroll ? getScroll(html) : 0
    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0
    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    }
    return getClientRect(offset)
  }
  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */

  function isFixed (element) {
    var nodeName = element.nodeName

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false
    }

    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true
    }

    var parentNode = getParentNode(element)

    if (!parentNode) {
      return false
    }

    return isFixed(parentNode)
  }
  /**
   * Finds the first parent of an element that has a transformed property defined
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} first transformed parent or documentElement
   */

  function getFixedPositionOffsetParent (element) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement
    }

    var el = element.parentElement

    while (el && getStyleComputedProperty(el, 'transform') === 'none') {
      el = el.parentElement
    }

    return el || document.documentElement
  }
  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @param {Boolean} fixedPosition - Is in fixed position mode
   * @returns {Object} Coordinates of the boundaries
   */

  function getBoundaries (popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false // NOTE: 1 DOM access here

    var boundaries = {
      top: 0,
      left: 0
    }
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)) // Handle viewport case

    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition)
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0

      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference))

        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement
      } else {
        boundariesNode = boundariesElement
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition) // In case of HTML, we need a different computation

      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument)
        var height = _getWindowSizes.height
        var width = _getWindowSizes.width

        boundaries.top += offsets.top - offsets.marginTop
        boundaries.bottom = height + offsets.top
        boundaries.left += offsets.left - offsets.marginLeft
        boundaries.right = width + offsets.left
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets
      }
    } // Add paddings

    padding = padding || 0
    var isPaddingNumber = typeof padding === 'number'
    boundaries.left += isPaddingNumber ? padding : padding.left || 0
    boundaries.top += isPaddingNumber ? padding : padding.top || 0
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0
    return boundaries
  }

  function getArea (_ref) {
    var width = _ref.width
    var height = _ref.height
    return width * height
  }
  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function computeAutoPlacement (placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0

    if (placement.indexOf('auto') === -1) {
      return placement
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement)
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    }
    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      })
    }).sort(function (a, b) {
      return b.area - a.area
    })
    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width
      var height = _ref2.height
      return width >= popper.clientWidth && height >= popper.clientHeight
    })
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key
    var variation = placement.split('-')[1]
    return computedPlacement + (variation ? '-' + variation : '')
  }
  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @param {Element} fixedPosition - is in fixed position mode
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */

  function getReferenceOffsets (state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference))
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition)
  }
  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */

  function getOuterSizes (element) {
    var window = element.ownerDocument.defaultView
    var styles = window.getComputedStyle(element)
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0)
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0)
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    }
    return result
  }
  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */

  function getOppositePlacement (placement) {
    var hash = {
      left: 'right',
      right: 'left',
      bottom: 'top',
      top: 'bottom'
    }
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched]
    })
  }
  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */

  function getPopperOffsets (popper, referenceOffsets, placement) {
    placement = placement.split('-')[0] // Get popper node sizes

    var popperRect = getOuterSizes(popper) // Add position, width and height to our offsets object

    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    } // depending by the popper placement we have to compute its offsets slightly differently

    var isHoriz = ['right', 'left'].indexOf(placement) !== -1
    var mainSide = isHoriz ? 'top' : 'left'
    var secondarySide = isHoriz ? 'left' : 'top'
    var measurement = isHoriz ? 'height' : 'width'
    var secondaryMeasurement = !isHoriz ? 'height' : 'width'
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2

    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement]
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)]
    }

    return popperOffsets
  }
  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */

  function find (arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check)
    } // use `filter` to obtain the same behavior of `find`

    return arr.filter(check)[0]
  }
  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */

  function findIndex (arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value
      })
    } // use `find` + `indexOf` if `findIndex` isn't supported

    var match = find(arr, function (obj) {
      return obj[prop] === value
    })
    return arr.indexOf(match)
  }
  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */

  function runModifiers (modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends))
    modifiersToRun.forEach(function (modifier) {
      if (modifier.function) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!')
      }

      var fn = modifier['function'] || modifier.fn // eslint-disable-line dot-notation

      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper)
        data.offsets.reference = getClientRect(data.offsets.reference)
        data = fn(data, modifier)
      }
    })
    return data
  }
  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */

  function update () {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    } // compute reference element offsets

    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed) // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding) // store the computed placement inside `originalPlacement`

    data.originalPlacement = data.placement
    data.positionFixed = this.options.positionFixed // compute the popper offsets

    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement)
    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute' // run the modifiers

    data = runModifiers(this.modifiers, data) // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback

    if (!this.state.isCreated) {
      this.state.isCreated = true
      this.options.onCreate(data)
    } else {
      this.options.onUpdate(data)
    }
  }
  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */

  function isModifierEnabled (modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name
      var enabled = _ref.enabled
      return enabled && name === modifierName
    })
  }
  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */

  function getSupportedPropertyName (property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O']
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1)

    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i]
      var toCheck = prefix ? '' + prefix + upperProp : property

      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck
      }
    }

    return null
  }
  /**
   * Destroys the popper.
   * @method
   * @memberof Popper
   */

  function destroy () {
    this.state.isDestroyed = true // touch DOM only if `applyStyle` modifier is enabled

    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement')
      this.popper.style.position = ''
      this.popper.style.top = ''
      this.popper.style.left = ''
      this.popper.style.right = ''
      this.popper.style.bottom = ''
      this.popper.style.willChange = ''
      this.popper.style[getSupportedPropertyName('transform')] = ''
    }

    this.disableEventListeners() // remove the popper if user explicitly asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it

    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper)
    }

    return this
  }
  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */

  function getWindow (element) {
    var ownerDocument = element.ownerDocument
    return ownerDocument ? ownerDocument.defaultView : window
  }

  function attachToScrollParents (scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY'
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent
    target.addEventListener(event, callback, {
      passive: true
    })

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents)
    }

    scrollParents.push(target)
  }
  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */

  function setupEventListeners (reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound
    getWindow(reference).addEventListener('resize', state.updateBound, {
      passive: true
    }) // Scroll event listener on scroll parents

    var scrollElement = getScrollParent(reference)
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents)
    state.scrollElement = scrollElement
    state.eventsEnabled = true
    return state
  }
  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */

  function enableEventListeners () {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate)
    }
  }
  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */

  function removeEventListeners (reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound) // Remove scroll event listener on scroll parents

    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound)
    }) // Reset state

    state.updateBound = null
    state.scrollParents = []
    state.scrollElement = null
    state.eventsEnabled = false
    return state
  }
  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger `onUpdate` callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */

  function disableEventListeners () {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate)
      this.state = removeEventListeners(this.reference, this.state)
    }
  }
  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */

  function isNumeric (n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n)
  }
  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */

  function setStyles (element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '' // add unit if the value is numeric and is one of the following

      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px'
      }

      element.style[prop] = styles[prop] + unit
    })
  }
  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */

  function setAttributes (element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop]

      if (value !== false) {
        element.setAttribute(prop, attributes[prop])
      } else {
        element.removeAttribute(prop)
      }
    })
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */

  function applyStyle (data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles) // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element

    setAttributes(data.instance.popper, data.attributes) // if arrowElement is defined and arrowStyles has some properties

    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles)
    }

    return data
  }
  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper
   * @param {Object} options - Popper.js options
   */

  function applyStyleOnLoad (reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed) // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value

    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding)
    popper.setAttribute('x-placement', placement) // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations

    setStyles(popper, {
      position: options.positionFixed ? 'fixed' : 'absolute'
    })
    return options
  }
  /**
   * @function
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Boolean} shouldRound - If the offsets should be rounded at all
   * @returns {Object} The popper's position offsets rounded
   *
   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
   * good as it can be within reason.
   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
   *
   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
   * as well on High DPI screens).
   *
   * Firefox prefers no rounding for positioning and does not have blurriness on
   * high DPI screens.
   *
   * Only horizontal placement and left/right values need to be considered.
   */

  function getRoundedOffsets (data, shouldRound) {
    var _data$offsets = data.offsets
    var popper = _data$offsets.popper
    var reference = _data$offsets.reference
    var round = Math.round
    var floor = Math.floor

    var noRound = function noRound (v) {
      return v
    }

    var referenceWidth = round(reference.width)
    var popperWidth = round(popper.width)
    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1
    var isVariation = data.placement.indexOf('-') !== -1
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor
    var verticalToInteger = !shouldRound ? noRound : round
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    }
  }

  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent)
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function computeStyle (data, options) {
    var x = options.x
    var y = options.y
    var popper = data.offsets.popper // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle'
    }).gpuAcceleration

    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!')
    }

    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration
    var offsetParent = getOffsetParent(data.instance.popper)
    var offsetParentRect = getBoundingClientRect(offsetParent) // Styles

    var styles = {
      position: popper.position
    }
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox)
    var sideA = x === 'bottom' ? 'top' : 'bottom'
    var sideB = y === 'right' ? 'left' : 'right' // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed

    var prefixedProperty = getSupportedPropertyName('transform') // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.

    var left = void 0
    var top = void 0

    if (sideA === 'bottom') {
      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
      // and not the bottom of the html element
      if (offsetParent.nodeName === 'HTML') {
        top = -offsetParent.clientHeight + offsets.bottom
      } else {
        top = -offsetParentRect.height + offsets.bottom
      }
    } else {
      top = offsets.top
    }

    if (sideB === 'right') {
      if (offsetParent.nodeName === 'HTML') {
        left = -offsetParent.clientWidth + offsets.right
      } else {
        left = -offsetParentRect.width + offsets.right
      }
    } else {
      left = offsets.left
    }

    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)'
      styles[sideA] = 0
      styles[sideB] = 0
      styles.willChange = 'transform'
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1
      var invertLeft = sideB === 'right' ? -1 : 1
      styles[sideA] = top * invertTop
      styles[sideB] = left * invertLeft
      styles.willChange = sideA + ', ' + sideB
    } // Attributes

    var attributes = {
      'x-placement': data.placement
    } // Update `data` attributes, styles and arrowStyles

    data.attributes = _extends({}, attributes, data.attributes)
    data.styles = _extends({}, styles, data.styles)
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles)
    return data
  }
  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */

  function isModifierRequired (modifiers, requestingName, requestedName) {
    var requesting = find(modifiers, function (_ref) {
      var name = _ref.name
      return name === requestingName
    })
    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order
    })

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`'

      var requested = '`' + requestedName + '`'
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!')
    }

    return isRequired
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function arrow (data, options) {
    var _data$offsets$arrow // arrow depends on keepTogether in order to work

    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data
    }

    var arrowElement = options.element // if arrowElement is a string, suppose it's a CSS selector

    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement) // if arrowElement is not found, don't run the modifier

      if (!arrowElement) {
        return data
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!')
        return data
      }
    }

    var placement = data.placement.split('-')[0]
    var _data$offsets = data.offsets
    var popper = _data$offsets.popper
    var reference = _data$offsets.reference
    var isVertical = ['left', 'right'].indexOf(placement) !== -1
    var len = isVertical ? 'height' : 'width'
    var sideCapitalized = isVertical ? 'Top' : 'Left'
    var side = sideCapitalized.toLowerCase()
    var altSide = isVertical ? 'left' : 'top'
    var opSide = isVertical ? 'bottom' : 'right'
    var arrowElementSize = getOuterSizes(arrowElement)[len] //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjunction
    //
    // top/left side

    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize)
    } // bottom/right side

    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide]
    }

    data.offsets.popper = getClientRect(data.offsets.popper) // compute center of the popper

    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2 // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available

    var css = getStyleComputedProperty(data.instance.popper)
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized])
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'])
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide // prevent arrowElement from being placed not contiguously to its popper

    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0)
    data.arrowElement = arrowElement
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow)
    return data
  }
  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */

  function getOppositeVariation (variation) {
    if (variation === 'end') {
      return 'start'
    } else if (variation === 'start') {
      return 'end'
    }

    return variation
  }
  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-end` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */

  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'] // Get rid of `auto` `auto-start` and `auto-end`

  var validPlacements = placements.slice(3)
  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */

  function clockwise (placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false
    var index = validPlacements.indexOf(placement)
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index))
    return counter ? arr.reverse() : arr
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function flip (data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed)
    var placement = data.placement.split('-')[0]
    var placementOpposite = getOppositePlacement(placement)
    var variation = data.placement.split('-')[1] || ''
    var flipOrder = []

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite]
        break

      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement)
        break

      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true)
        break

      default:
        flipOrder = options.behavior
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data
      }

      placement = data.placement.split('-')[0]
      placementOpposite = getOppositePlacement(placement)
      var popperOffsets = data.offsets.popper
      var refOffsets = data.offsets.reference // using floor because the reference offsets may contain decimals we are not going to consider here

      var floor = Math.floor
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom)
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left)
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right)
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top)
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom)
      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom // flip the variation if required

      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1 // flips variation if reference element overflows boundaries

      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom) // flips variation if popper content overflows boundaries

      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop)
      var flippedVariation = flippedVariationByRef || flippedVariationByContent

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1]
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation)
        }

        data.placement = placement + (variation ? '-' + variation : '') // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future

        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement))
        data = runModifiers(data.instance.modifiers, data, 'flip')
      }
    })
    return data
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function keepTogether (data) {
    var _data$offsets = data.offsets
    var popper = _data$offsets.popper
    var reference = _data$offsets.reference
    var placement = data.placement.split('-')[0]
    var floor = Math.floor
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1
    var side = isVertical ? 'right' : 'bottom'
    var opSide = isVertical ? 'left' : 'top'
    var measurement = isVertical ? 'width' : 'height'

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement]
    }

    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side])
    }

    return data
  }
  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */

  function toValue (str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/)
    var value = +split[1]
    var unit = split[2] // If it's not a number it's an operator, I guess

    if (!value) {
      return str
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0

      switch (unit) {
        case '%p':
          element = popperOffsets
          break

        case '%':
        case '%r':
        default:
          element = referenceOffsets
      }

      var rect = getClientRect(element)
      return rect[measurement] / 100 * value
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0

      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)
      }

      return size / 100 * value
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value
    }
  }
  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */

  function parseOffset (offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0] // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one

    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1 // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim()
    }) // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space

    var divider = fragments.indexOf(find(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1
    }))

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.')
    } // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.

    var splitRegex = /\s*,\s*|\s+/
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments] // Convert the values with units to absolute pixels to allow our computations

    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width'
      var mergeWithPrevious = false
      return op // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
        .reduce(function (a, b) {
          if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
            a[a.length - 1] = b
            mergeWithPrevious = true
            return a
          } else if (mergeWithPrevious) {
            a[a.length - 1] += b
            mergeWithPrevious = false
            return a
          } else {
            return a.concat(b)
          }
        }, []) // Here we convert the string values into number values (in px)
        .map(function (str) {
          return toValue(str, measurement, popperOffsets, referenceOffsets)
        })
    }) // Loop trough the offsets arrays and execute the operations

    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1)
        }
      })
    })
    return offsets
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */

  function offset (data, _ref) {
    var offset = _ref.offset
    var placement = data.placement
    var _data$offsets = data.offsets
    var popper = _data$offsets.popper
    var reference = _data$offsets.reference
    var basePlacement = placement.split('-')[0]
    var offsets = void 0

    if (isNumeric(+offset)) {
      offsets = [+offset, 0]
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement)
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0]
      popper.left -= offsets[1]
    } else if (basePlacement === 'right') {
      popper.top += offsets[0]
      popper.left += offsets[1]
    } else if (basePlacement === 'top') {
      popper.left += offsets[0]
      popper.top -= offsets[1]
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0]
      popper.top += offsets[1]
    }

    data.popper = popper
    return data
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function preventOverflow (data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper) // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken

    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement)
    } // NOTE: DOM access here
    // resets the popper's position so that the document size can be calculated excluding
    // the size of the popper element itself

    var transformProp = getSupportedPropertyName('transform')
    var popperStyles = data.instance.popper.style // assignment to help minification

    var top = popperStyles.top
    var left = popperStyles.left
    var transform = popperStyles[transformProp]
    popperStyles.top = ''
    popperStyles.left = ''
    popperStyles[transformProp] = ''
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed) // NOTE: DOM access here
    // restores the original style properties after the offsets have been computed

    popperStyles.top = top
    popperStyles.left = left
    popperStyles[transformProp] = transform
    options.boundaries = boundaries
    var order = options.priority
    var popper = data.offsets.popper
    var check = {
      primary: function primary (placement) {
        var value = popper[placement]

        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement])
        }

        return defineProperty({}, placement, value)
      },
      secondary: function secondary (placement) {
        var mainSide = placement === 'right' ? 'left' : 'top'
        var value = popper[mainSide]

        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height))
        }

        return defineProperty({}, mainSide, value)
      }
    }
    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary'
      popper = _extends({}, popper, check[side](placement))
    })
    data.offsets.popper = popper
    return data
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function shift (data) {
    var placement = data.placement
    var basePlacement = placement.split('-')[0]
    var shiftvariation = placement.split('-')[1] // if shift shiftvariation is specified, run the modifier

    if (shiftvariation) {
      var _data$offsets = data.offsets
      var reference = _data$offsets.reference
      var popper = _data$offsets.popper
      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1
      var side = isVertical ? 'left' : 'top'
      var measurement = isVertical ? 'width' : 'height'
      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      }
      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation])
    }

    return data
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function hide (data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data
    }

    var refRect = data.offsets.reference
    var bound = find(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow'
    }).boundaries

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data
      }

      data.hide = true
      data.attributes['x-out-of-boundaries'] = ''
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data
      }

      data.hide = false
      data.attributes['x-out-of-boundaries'] = false
    }

    return data
  }
  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */

  function inner (data) {
    var placement = data.placement
    var basePlacement = placement.split('-')[0]
    var _data$offsets = data.offsets
    var popper = _data$offsets.popper
    var reference = _data$offsets.reference
    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1
    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1
    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0)
    data.placement = getOppositePlacement(placement)
    data.offsets.popper = getClientRect(popper)
    return data
  }
  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */

  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: offset,

      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: preventOverflow,

      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],

      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: arrow,

      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: flip,

      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: 'flip',

      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,

      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: 'viewport',

      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,

      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,

      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,

      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: computeStyle,

      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,

      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',

      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,

      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,

      /** @prop {ModifierFn} */
      fn: applyStyle,

      /** @prop {Function} */
      onLoad: applyStyleOnLoad,

      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: undefined
    }
  }
  /**
   * The `dataObject` is an object containing all the information used by Popper.js.
   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overridden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass an object with the same
   * structure of the `options` object, as the 3rd argument. For example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */

  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,

    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate () {},

    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate () {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers: modifiers
  }
  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */
  // Utils
  // Methods

  var Popper = (function () {
    /**
     * Creates a new Popper.js instance.
     * @class Popper
     * @param {Element|referenceObject} reference - The reference element used to position the popper
     * @param {Element} popper - The HTML / XML element used as the popper
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper (reference, popper) {
      var _this = this

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}
      classCallCheck(this, Popper)

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update)
      } // make update() debounced, so that it only runs at most once-per-tick

      this.update = debounce(this.update.bind(this)) // with {} we create a new object with the options inside it

      this.options = _extends({}, Popper.Defaults, options) // init state

      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      } // get reference and popper elements (allow jQuery wrappers)

      this.reference = reference && reference.jquery ? reference[0] : reference
      this.popper = popper && popper.jquery ? popper[0] : popper // Deep merge modifiers options

      this.options.modifiers = {}
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {})
      }) // Refactoring modifiers' list (Object => Array)

      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name])
      }) // sort the modifiers by order
        .sort(function (a, b) {
          return a.order - b.order
        }) // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state)
        }
      }) // fire the first update to position the popper in the right place

      this.update()
      var eventsEnabled = this.options.eventsEnabled

      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners()
      }

      this.state.eventsEnabled = eventsEnabled
    } // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs

    createClass(Popper, [{
      key: 'update',
      value: function update$$1 () {
        return update.call(this)
      }
    }, {
      key: 'destroy',
      value: function destroy$$1 () {
        return destroy.call(this)
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1 () {
        return enableEventListeners.call(this)
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1 () {
        return disableEventListeners.call(this)
      }
      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }])
    return Popper
  }())
  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10.
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */

  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils
  Popper.placements = placements
  Popper.Defaults = Defaults

  /** !
  * tippy.js v5.2.1
  * (c) 2017-2020 atomiks
  * MIT License
  */

  function _extends$1 () {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key]
          }
        }
      }

      return target
    }

    return _extends$1.apply(this, arguments)
  }

  var version = '5.2.1'
  /**
   * Triggers reflow
   */

  function reflow (element) {
    void element.offsetHeight
  }
  /**
   * Sets the innerHTML of an element
   */

  function setInnerHTML (element, html) {
    element[innerHTML()] = html
  }
  /**
   * Determines if the value is a reference element
   */

  function isReferenceElement (value) {
    return !!(value && value._tippy && value._tippy.reference === value)
  }
  /**
   * Safe .hasOwnProperty check, for prototype-less objects
   */

  function hasOwnProperty (obj, key) {
    return {}.hasOwnProperty.call(obj, key)
  }
  /**
   * Returns an array of elements based on the value
   */

  function getArrayOfElements (value) {
    if (isElement(value)) {
      return [value]
    }

    if (isNodeList(value)) {
      return arrayFrom(value)
    }

    if (Array.isArray(value)) {
      return value
    }

    return arrayFrom(document.querySelectorAll(value))
  }
  /**
   * Returns a value at a given index depending on if it's an array or number
   */

  function getValueAtIndexOrReturn (value, index, defaultValue) {
    if (Array.isArray(value)) {
      var v = value[index]
      return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v
    }

    return value
  }
  /**
   * Prevents errors from being thrown while accessing nested modifier objects
   * in `popperOptions`
   */

  function getModifier (obj, key) {
    return obj && obj.modifiers && obj.modifiers[key]
  }
  /**
   * Determines if the value is of type
   */

  function isType (value, type) {
    var str = {}.toString.call(value)
    return str.indexOf('[object') === 0 && str.indexOf(type + ']') > -1
  }
  /**
   * Determines if the value is of type Element
   */

  function isElement (value) {
    return isType(value, 'Element')
  }
  /**
   * Determines if the value is of type NodeList
   */

  function isNodeList (value) {
    return isType(value, 'NodeList')
  }
  /**
   * Determines if the value is of type MouseEvent
   */

  function isMouseEvent (value) {
    return isType(value, 'MouseEvent')
  }
  /**
   * Firefox extensions don't allow setting .innerHTML directly, this will trick
   * it
   */

  function innerHTML () {
    return 'innerHTML'
  }
  /**
   * Evaluates a function if one, or returns the value
   */

  function invokeWithArgsOrReturn (value, args) {
    return typeof value === 'function' ? value.apply(void 0, args) : value
  }
  /**
   * Sets a popperInstance modifier's property to a value
   */

  function setModifierValue (modifiers, name, property, value) {
    modifiers.filter(function (m) {
      return m.name === name
    })[0][property] = value
  }
  /**
   * Returns a new `div` element
   */

  function div () {
    return document.createElement('div')
  }
  /**
   * Applies a transition duration to a list of elements
   */

  function setTransitionDuration (els, value) {
    els.forEach(function (el) {
      if (el) {
        el.style.transitionDuration = value + 'ms'
      }
    })
  }
  /**
   * Sets the visibility state to elements so they can begin to transition
   */

  function setVisibilityState (els, state) {
    els.forEach(function (el) {
      if (el) {
        el.setAttribute('data-state', state)
      }
    })
  }
  /**
   * Debounce utility. To avoid bloating bundle size, we're only passing 1
   * argument here, a more generic function would pass all arguments. Only
   * `onMouseMove` uses this which takes the event object for now.
   */

  function debounce$1 (fn, ms) {
    // Avoid wrapping in `setTimeout` if ms is 0 anyway
    if (ms === 0) {
      return fn
    }

    var timeout
    return function (arg) {
      clearTimeout(timeout)
      timeout = setTimeout(function () {
        fn(arg)
      }, ms)
    }
  }
  /**
   * Preserves the original function invocation when another function replaces it
   */

  function preserveInvocation (originalFn, currentFn, args) {
    if (originalFn && originalFn !== currentFn) {
      originalFn.apply(void 0, args)
    }
  }
  /**
   * Ponyfill for Array.from - converts iterable values to an array
   */

  function arrayFrom (value) {
    return [].slice.call(value)
  }
  /**
   * Works like Element.prototype.closest, but uses a callback instead
   */

  function closestCallback (element, callback) {
    while (element) {
      if (callback(element)) {
        return element
      }

      element = element.parentElement
    }

    return null
  }
  /**
   * Determines if an array or string includes a string
   */

  function includes (a, b) {
    return a.indexOf(b) > -1
  }
  /**
   * Creates an array from string of values separated by whitespace
   */

  function splitBySpaces (value) {
    return value.split(/\s+/).filter(Boolean)
  }
  /**
   * Returns the `nextValue` if `nextValue` is not `undefined`, otherwise returns
   * `currentValue`
   */

  function useIfDefined (nextValue, currentValue) {
    return nextValue !== undefined ? nextValue : currentValue
  }
  /**
   * Converts a value that's an array or single value to an array
   */

  function normalizeToArray (value) {
    return [].concat(value)
  }
  /**
   * Returns the ownerDocument of the first available element, otherwise global
   * document
   */

  function getOwnerDocument (elementOrElements) {
    var _normalizeToArray = normalizeToArray(elementOrElements)
    var element = _normalizeToArray[0]

    return element ? element.ownerDocument || document : document
  }
  /**
   * Adds item to array if array does not contain it
   */

  function pushIfUnique (arr, value) {
    if (arr.indexOf(value) === -1) {
      arr.push(value)
    }
  }
  /**
   * Adds `px` if value is a number, or returns it directly
   */

  function appendPxIfNumber (value) {
    return typeof value === 'number' ? value + 'px' : value
  }
  /**
   * Filters out duplicate elements in an array
   */

  function unique (arr) {
    return arr.filter(function (item, index) {
      return arr.indexOf(item) === index
    })
  }
  /**
   * Returns number from number or CSS units string
   */

  function getNumber (value) {
    return typeof value === 'number' ? value : parseFloat(value)
  }
  /**
   * Gets number or CSS string units in pixels (e.g. `1rem` -> 16)
   */

  function getUnitsInPx (doc, value) {
    var isRem = typeof value === 'string' && includes(value, 'rem')
    var html = doc.documentElement
    var rootFontSize = 16

    if (html && isRem) {
      return parseFloat(getComputedStyle(html).fontSize || String(rootFontSize)) * getNumber(value)
    }

    return getNumber(value)
  }
  /**
   * Adds the `distancePx` value to the placement of a Popper.Padding object
   */

  function getComputedPadding (basePlacement, padding, distancePx) {
    if (padding === void 0) {
      padding = 5
    }

    var freshPaddingObject = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
    var keys = Object.keys(freshPaddingObject)
    return keys.reduce(function (obj, key) {
      obj[key] = typeof padding === 'number' ? padding : padding[key]

      if (basePlacement === key) {
        obj[key] = typeof padding === 'number' ? padding + distancePx : padding[basePlacement] + distancePx
      }

      return obj
    }, freshPaddingObject)
  }

  var pluginProps = {
    animateFill: false,
    followCursor: false,
    inlinePositioning: false,
    sticky: false
  }

  var defaultProps = _extends$1({
    allowHTML: true,
    animation: 'fade',
    appendTo: function appendTo () {
      return document.body
    },
    aria: 'describedby',
    arrow: true,
    boundary: 'scrollParent',
    content: '',
    delay: 0,
    distance: 10,
    duration: [300, 250],
    flip: true,
    flipBehavior: 'flip',
    flipOnUpdate: false,
    hideOnClick: true,
    ignoreAttributes: false,
    inertia: false,
    interactive: false,
    interactiveBorder: 2,
    interactiveDebounce: 0,
    lazy: true,
    maxWidth: 350,
    multiple: false,
    offset: 0,
    onAfterUpdate: function onAfterUpdate () {},
    onBeforeUpdate: function onBeforeUpdate () {},
    onCreate: function onCreate () {},
    onDestroy: function onDestroy () {},
    onHidden: function onHidden () {},
    onHide: function onHide () {},
    onMount: function onMount () {},
    onShow: function onShow () {},
    onShown: function onShown () {},
    onTrigger: function onTrigger () {},
    onUntrigger: function onUntrigger () {},
    placement: 'top',
    plugins: [],
    popperOptions: {},
    role: 'tooltip',
    showOnCreate: false,
    theme: '',
    touch: true,
    trigger: 'mouseenter focus',
    triggerTarget: null,
    updateDuration: 0,
    zIndex: 9999
  }, pluginProps)

  var defaultKeys = Object.keys(defaultProps)
  /**
   * If the setProps() method encounters one of these, the popperInstance must be
   * recreated
   */

  var POPPER_INSTANCE_DEPENDENCIES = ['arrow', 'boundary', 'distance', 'flip', 'flipBehavior', 'flipOnUpdate', 'offset', 'placement', 'popperOptions']
  /**
   * Mutates the defaultProps object by setting the props specified
   */

  var setDefaultProps = function setDefaultProps (partialProps) {
    var keys = Object.keys(partialProps)
    keys.forEach(function (key) {
      defaultProps[key] = partialProps[key]
    })
  }
  /**
   * Returns an extended props object including plugin props
   */

  function getExtendedPassedProps (passedProps) {
    var plugins = passedProps.plugins || []
    var pluginProps = plugins.reduce(function (acc, plugin) {
      var name = plugin.name
      var defaultValue = plugin.defaultValue

      if (name) {
        acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue
      }

      return acc
    }, {})
    return _extends$1({}, passedProps, {}, pluginProps)
  }
  /**
   * Returns an object of optional props from data-tippy-* attributes
   */

  function getDataAttributeProps (reference, plugins) {
    var propKeys = plugins ? Object.keys(getExtendedPassedProps(_extends$1({}, defaultProps, {
      plugins: plugins
    }))) : defaultKeys
    var props = propKeys.reduce(function (acc, key) {
      var valueAsString = (reference.getAttribute('data-tippy-' + key) || '').trim()

      if (!valueAsString) {
        return acc
      }

      if (key === 'content') {
        acc[key] = valueAsString
      } else {
        try {
          acc[key] = JSON.parse(valueAsString)
        } catch (e) {
          acc[key] = valueAsString
        }
      }

      return acc
    }, {})
    return props
  }
  /**
   * Evaluates the props object by merging data attributes and disabling
   * conflicting props where necessary
   */

  function evaluateProps (reference, props) {
    var out = _extends$1({}, props, {
      content: invokeWithArgsOrReturn(props.content, [reference])
    }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins))

    if (out.interactive) {
      out.aria = null
    }

    return out
  }

  var PASSIVE = {
    passive: true
  }
  var IOS_CLASS = 'tippy-iOS'
  var POPPER_CLASS = 'tippy-popper'
  var TOOLTIP_CLASS = 'tippy-tooltip'
  var CONTENT_CLASS = 'tippy-content'
  var ARROW_CLASS = 'tippy-arrow'
  var SVG_ARROW_CLASS = 'tippy-svg-arrow'
  var POPPER_SELECTOR = '.' + POPPER_CLASS
  var TOOLTIP_SELECTOR = '.' + TOOLTIP_CLASS
  var CONTENT_SELECTOR = '.' + CONTENT_CLASS
  var ARROW_SELECTOR = '.' + ARROW_CLASS
  var SVG_ARROW_SELECTOR = '.' + SVG_ARROW_CLASS
  var currentInput = {
    isTouch: false
  }
  var lastMouseMoveTime = 0
  /**
   * When a `touchstart` event is fired, it's assumed the user is using touch
   * input. We'll bind a `mousemove` event listener to listen for mouse input in
   * the future. This way, the `isTouch` property is fully dynamic and will handle
   * hybrid devices that use a mix of touch + mouse input.
   */

  function onDocumentTouchStart () {
    if (currentInput.isTouch) {
      return
    }

    currentInput.isTouch = true

    if (window.performance) {
      document.addEventListener('mousemove', onDocumentMouseMove)
    }
  }
  /**
   * When two `mousemove` event are fired consecutively within 20ms, it's assumed
   * the user is using mouse input again. `mousemove` can fire on touch devices as
   * well, but very rarely that quickly.
   */

  function onDocumentMouseMove () {
    var now = performance.now()

    if (now - lastMouseMoveTime < 20) {
      currentInput.isTouch = false
      document.removeEventListener('mousemove', onDocumentMouseMove)
    }

    lastMouseMoveTime = now
  }
  /**
   * When an element is in focus and has a tippy, leaving the tab/window and
   * returning causes it to show again. For mouse users this is unexpected, but
   * for keyboard use it makes sense.
   * TODO: find a better technique to solve this problem
   */

  function onWindowBlur () {
    var activeElement = document.activeElement

    if (isReferenceElement(activeElement)) {
      var instance = activeElement._tippy

      if (activeElement.blur && !instance.state.isVisible) {
        activeElement.blur()
      }
    }
  }
  /**
   * Adds the needed global event listeners
   */

  function bindGlobalEventListeners () {
    document.addEventListener('touchstart', onDocumentTouchStart, _extends$1({}, PASSIVE, {
      capture: true
    }))
    window.addEventListener('blur', onWindowBlur)
  }

  var isBrowser$1 = typeof window !== 'undefined' && typeof document !== 'undefined'
  var ua = isBrowser$1 ? navigator.userAgent : ''
  var isIE$1 = /MSIE |Trident\//.test(ua)
  var isIOS = isBrowser$1 && /iPhone|iPad|iPod/.test(navigator.platform)

  function updateIOSClass (isAdd) {
    var shouldAdd = isAdd && isIOS && currentInput.isTouch
    document.body.classList[shouldAdd ? 'add' : 'remove'](IOS_CLASS)
  }
  /**
   * Returns the popper's placement, ignoring shifting (top-start, etc)
   */

  function getBasePlacement (placement) {
    return placement.split('-')[0]
  }
  /**
   * Adds `data-inertia` attribute
   */

  function addInertia (tooltip) {
    tooltip.setAttribute('data-inertia', '')
  }
  /**
   * Removes `data-inertia` attribute
   */

  function removeInertia (tooltip) {
    tooltip.removeAttribute('data-inertia')
  }
  /**
   * Adds interactive-related attributes
   */

  function addInteractive (tooltip) {
    tooltip.setAttribute('data-interactive', '')
  }
  /**
   * Removes interactive-related attributes
   */

  function removeInteractive (tooltip) {
    tooltip.removeAttribute('data-interactive')
  }
  /**
   * Sets the content of a tooltip
   */

  function setContent (contentEl, props) {
    if (isElement(props.content)) {
      setInnerHTML(contentEl, '')
      contentEl.appendChild(props.content)
    } else if (typeof props.content !== 'function') {
      var key = props.allowHTML ? 'innerHTML' : 'textContent'
      contentEl[key] = props.content
    }
  }
  /**
   * Returns the child elements of a popper element
   */

  function getChildren (popper) {
    return {
      tooltip: popper.querySelector(TOOLTIP_SELECTOR),
      content: popper.querySelector(CONTENT_SELECTOR),
      arrow: popper.querySelector(ARROW_SELECTOR) || popper.querySelector(SVG_ARROW_SELECTOR)
    }
  }
  /**
   * Creates an arrow element and returns it
   */

  function createArrowElement (arrow) {
    var arrowElement = div()

    if (arrow === true) {
      arrowElement.className = ARROW_CLASS
    } else {
      arrowElement.className = SVG_ARROW_CLASS

      if (isElement(arrow)) {
        arrowElement.appendChild(arrow)
      } else {
        setInnerHTML(arrowElement, arrow)
      }
    }

    return arrowElement
  }
  /**
   * Constructs the popper element and returns it
   */

  function createPopperElement (id, props) {
    var popper = div()
    popper.className = POPPER_CLASS
    popper.style.position = 'absolute'
    popper.style.top = '0'
    popper.style.left = '0'
    var tooltip = div()
    tooltip.className = TOOLTIP_CLASS
    tooltip.id = 'tippy-' + id
    tooltip.setAttribute('data-state', 'hidden')
    tooltip.setAttribute('tabindex', '-1')
    updateTheme(tooltip, 'add', props.theme)
    var content = div()
    content.className = CONTENT_CLASS
    content.setAttribute('data-state', 'hidden')

    if (props.interactive) {
      addInteractive(tooltip)
    }

    if (props.arrow) {
      tooltip.setAttribute('data-arrow', '')
      tooltip.appendChild(createArrowElement(props.arrow))
    }

    if (props.inertia) {
      addInertia(tooltip)
    }

    setContent(content, props)
    tooltip.appendChild(content)
    popper.appendChild(tooltip)
    updatePopperElement(popper, props, props)
    return popper
  }
  /**
   * Updates the popper element based on the new props
   */

  function updatePopperElement (popper, prevProps, nextProps) {
    var _getChildren = getChildren(popper)
    var tooltip = _getChildren.tooltip
    var content = _getChildren.content
    var arrow = _getChildren.arrow

    popper.style.zIndex = '' + nextProps.zIndex
    tooltip.setAttribute('data-animation', nextProps.animation)
    tooltip.style.maxWidth = appendPxIfNumber(nextProps.maxWidth)

    if (nextProps.role) {
      tooltip.setAttribute('role', nextProps.role)
    } else {
      tooltip.removeAttribute('role')
    }

    if (prevProps.content !== nextProps.content) {
      setContent(content, nextProps)
    } // arrow

    if (!prevProps.arrow && nextProps.arrow) {
      // false to true
      tooltip.appendChild(createArrowElement(nextProps.arrow))
      tooltip.setAttribute('data-arrow', '')
    } else if (prevProps.arrow && !nextProps.arrow) {
      // true to false
      tooltip.removeChild(arrow)
      tooltip.removeAttribute('data-arrow')
    } else if (prevProps.arrow !== nextProps.arrow) {
      // true to 'round' or vice-versa
      tooltip.removeChild(arrow)
      tooltip.appendChild(createArrowElement(nextProps.arrow))
    } // interactive

    if (!prevProps.interactive && nextProps.interactive) {
      addInteractive(tooltip)
    } else if (prevProps.interactive && !nextProps.interactive) {
      removeInteractive(tooltip)
    } // inertia

    if (!prevProps.inertia && nextProps.inertia) {
      addInertia(tooltip)
    } else if (prevProps.inertia && !nextProps.inertia) {
      removeInertia(tooltip)
    } // theme

    if (prevProps.theme !== nextProps.theme) {
      updateTheme(tooltip, 'remove', prevProps.theme)
      updateTheme(tooltip, 'add', nextProps.theme)
    }
  }
  /**
   * Add/remove transitionend listener from tooltip
   */

  function updateTransitionEndListener (tooltip, action, listener) {
    ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
      tooltip[action + 'EventListener'](event, listener)
    })
  }
  /**
   * Adds/removes theme from tooltip's classList
   */

  function updateTheme (tooltip, action, theme) {
    splitBySpaces(theme).forEach(function (name) {
      tooltip.classList[action](name + '-theme')
    })
  }
  /**
   * Determines if the mouse cursor is outside of the popper's interactive border
   * region
   */

  function isCursorOutsideInteractiveBorder (popperTreeData, event) {
    var clientX = event.clientX
    var clientY = event.clientY
    return popperTreeData.every(function (_ref) {
      var popperRect = _ref.popperRect
      var tooltipRect = _ref.tooltipRect
      var interactiveBorder = _ref.interactiveBorder // Get min/max bounds of both the popper and tooltip rects due to
      // `distance` offset

      var mergedRect = {
        top: Math.min(popperRect.top, tooltipRect.top),
        right: Math.max(popperRect.right, tooltipRect.right),
        bottom: Math.max(popperRect.bottom, tooltipRect.bottom),
        left: Math.min(popperRect.left, tooltipRect.left)
      }
      var exceedsTop = mergedRect.top - clientY > interactiveBorder
      var exceedsBottom = clientY - mergedRect.bottom > interactiveBorder
      var exceedsLeft = mergedRect.left - clientX > interactiveBorder
      var exceedsRight = clientX - mergedRect.right > interactiveBorder
      return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight
    })
  }

  var idCounter = 1
  var mouseMoveListeners = []
  /**
   * Used by `hideAll()`
   */

  var mountedInstances = []
  /**
   * Creates and returns a Tippy object. We're using a closure pattern instead of
   * a class so that the exposed object API is clean without private members
   * prefixed with `_`.
   */

  function createTippy (reference, passedProps) {
    var props = evaluateProps(reference, _extends$1({}, defaultProps, {}, getExtendedPassedProps(passedProps))) // If the reference shouldn't have multiple tippys, return null early

    if (!props.multiple && reference._tippy) {
      return null
    }
    /* ======================= 🔒 Private members 🔒 ======================= */

    var showTimeout
    var hideTimeout
    var scheduleHideAnimationFrame
    var isBeingDestroyed = false
    var isVisibleFromClick = false
    var didHideDueToDocumentMouseDown = false
    var popperUpdates = 0
    var lastTriggerEvent
    var currentMountCallback
    var currentTransitionEndListener
    var listeners = []
    var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce)
    var currentTarget // Support iframe contexts
    // Static check that assumes any of the `triggerTarget` or `reference`
    // nodes will never change documents, even when they are updated

    var doc = getOwnerDocument(props.triggerTarget || reference)
    /* ======================= 🔑 Public members 🔑 ======================= */

    var id = idCounter++
    var popper = createPopperElement(id, props)
    var popperChildren = getChildren(popper)
    var popperInstance = null
    var plugins = unique(props.plugins) // These two elements are static

    var tooltip = popperChildren.tooltip
    var content = popperChildren.content
    var transitionableElements = [tooltip, content]
    var state = {
      // The current real placement (`data-placement` attribute)
      currentPlacement: null,
      // Is the instance currently enabled?
      isEnabled: true,
      // Is the tippy currently showing and not transitioning out?
      isVisible: false,
      // Has the instance been destroyed?
      isDestroyed: false,
      // Is the tippy currently mounted to the DOM?
      isMounted: false,
      // Has the tippy finished transitioning in?
      isShown: false
    }
    var instance = {
      // properties
      id: id,
      reference: reference,
      popper: popper,
      popperChildren: popperChildren,
      popperInstance: popperInstance,
      props: props,
      state: state,
      plugins: plugins,
      // methods
      clearDelayTimeouts: clearDelayTimeouts,
      setProps: setProps,
      setContent: setContent,
      show: show,
      hide: hide,
      enable: enable,
      disable: disable,
      destroy: destroy
    }
    /* ==================== Initial instance mutations =================== */

    reference._tippy = instance
    popper._tippy = instance
    var pluginsHooks = plugins.map(function (plugin) {
      return plugin.fn(instance)
    })
    var hadAriaExpandedAttributeOnCreate = reference.hasAttribute('aria-expanded')
    addListenersToTriggerTarget()
    handleAriaExpandedAttribute()

    if (!props.lazy) {
      createPopperInstance()
    }

    invokeHook('onCreate', [instance])

    if (props.showOnCreate) {
      scheduleShow()
    } // Prevent a tippy with a delay from hiding if the cursor left then returned
    // before it started hiding

    popper.addEventListener('mouseenter', function () {
      if (instance.props.interactive && instance.state.isVisible) {
        instance.clearDelayTimeouts()
      }
    })
    popper.addEventListener('mouseleave', function (event) {
      if (instance.props.interactive && includes(instance.props.trigger, 'mouseenter')) {
        debouncedOnMouseMove(event)
        doc.addEventListener('mousemove', debouncedOnMouseMove)
      }
    })
    return instance
    /* ======================= 🔒 Private methods 🔒 ======================= */

    function getNormalizedTouchSettings () {
      var touch = instance.props.touch
      return Array.isArray(touch) ? touch : [touch, 0]
    }

    function getIsCustomTouchBehavior () {
      return getNormalizedTouchSettings()[0] === 'hold'
    }

    function getCurrentTarget () {
      return currentTarget || reference
    }

    function getDelay (isShow) {
      // For touch or keyboard input, force `0` delay for UX reasons
      // Also if the instance is mounted but not visible (transitioning out),
      // ignore delay
      if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
        return 0
      }

      return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay)
    }

    function invokeHook (hook, args, shouldInvokePropsHook) {
      if (shouldInvokePropsHook === void 0) {
        shouldInvokePropsHook = true
      }

      pluginsHooks.forEach(function (pluginHooks) {
        if (hasOwnProperty(pluginHooks, hook)) {
          // @ts-ignore
          pluginHooks[hook].apply(pluginHooks, args)
        }
      })

      if (shouldInvokePropsHook) {
        var _instance$props; // @ts-ignore

        (_instance$props = instance.props)[hook].apply(_instance$props, args)
      }
    }

    function handleAriaDescribedByAttribute () {
      var aria = instance.props.aria

      if (!aria) {
        return
      }

      var attr = 'aria-' + aria
      var id = tooltip.id
      var nodes = normalizeToArray(instance.props.triggerTarget || reference)
      nodes.forEach(function (node) {
        var currentValue = node.getAttribute(attr)

        if (instance.state.isVisible) {
          node.setAttribute(attr, currentValue ? currentValue + ' ' + id : id)
        } else {
          var nextValue = currentValue && currentValue.replace(id, '').trim()

          if (nextValue) {
            node.setAttribute(attr, nextValue)
          } else {
            node.removeAttribute(attr)
          }
        }
      })
    }

    function handleAriaExpandedAttribute () {
      // If the user has specified `aria-expanded` on their reference when the
      // instance was created, we have to assume they're controlling it externally
      // themselves
      if (hadAriaExpandedAttributeOnCreate) {
        return
      }

      var nodes = normalizeToArray(instance.props.triggerTarget || reference)
      nodes.forEach(function (node) {
        if (instance.props.interactive) {
          node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false')
        } else {
          node.removeAttribute('aria-expanded')
        }
      })
    }

    function cleanupInteractiveMouseListeners () {
      doc.body.removeEventListener('mouseleave', scheduleHide)
      doc.removeEventListener('mousemove', debouncedOnMouseMove)
      mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
        return listener !== debouncedOnMouseMove
      })
    }

    function onDocumentMouseDown (event) {
      // Clicked on interactive popper
      if (instance.props.interactive && popper.contains(event.target)) {
        return
      } // Clicked on the event listeners target

      if (getCurrentTarget().contains(event.target)) {
        if (currentInput.isTouch) {
          return
        }

        if (instance.state.isVisible && includes(instance.props.trigger, 'click')) {
          return
        }
      }

      if (instance.props.hideOnClick === true) {
        isVisibleFromClick = false
        instance.clearDelayTimeouts()
        instance.hide() // `mousedown` event is fired right before `focus` if pressing the
        // currentTarget. This lets a tippy with `focus` trigger know that it
        // should not show

        didHideDueToDocumentMouseDown = true
        setTimeout(function () {
          didHideDueToDocumentMouseDown = false
        }) // The listener gets added in `scheduleShow()`, but this may be hiding it
        // before it shows, and hide()'s early bail-out behavior can prevent it
        // from being cleaned up

        if (!instance.state.isMounted) {
          removeDocumentMouseDownListener()
        }
      }
    }

    function addDocumentMouseDownListener () {
      doc.addEventListener('mousedown', onDocumentMouseDown, true)
    }

    function removeDocumentMouseDownListener () {
      doc.removeEventListener('mousedown', onDocumentMouseDown, true)
    }

    function onTransitionedOut (duration, callback) {
      onTransitionEnd(duration, function () {
        if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
          callback()
        }
      })
    }

    function onTransitionedIn (duration, callback) {
      onTransitionEnd(duration, callback)
    }

    function onTransitionEnd (duration, callback) {
      function listener (event) {
        if (event.target === tooltip) {
          updateTransitionEndListener(tooltip, 'remove', listener)
          callback()
        }
      } // Make callback synchronous if duration is 0
      // `transitionend` won't fire otherwise

      if (duration === 0) {
        return callback()
      }

      updateTransitionEndListener(tooltip, 'remove', currentTransitionEndListener)
      updateTransitionEndListener(tooltip, 'add', listener)
      currentTransitionEndListener = listener
    }

    function on (eventType, handler, options) {
      if (options === void 0) {
        options = false
      }

      var nodes = normalizeToArray(instance.props.triggerTarget || reference)
      nodes.forEach(function (node) {
        node.addEventListener(eventType, handler, options)
        listeners.push({
          node: node,
          eventType: eventType,
          handler: handler,
          options: options
        })
      })
    }

    function addListenersToTriggerTarget () {
      if (getIsCustomTouchBehavior()) {
        on('touchstart', onTrigger, PASSIVE)
        on('touchend', onMouseLeave, PASSIVE)
      }

      splitBySpaces(instance.props.trigger).forEach(function (eventType) {
        if (eventType === 'manual') {
          return
        }

        on(eventType, onTrigger)

        switch (eventType) {
          case 'mouseenter':
            on('mouseleave', onMouseLeave)
            break

          case 'focus':
            on(isIE$1 ? 'focusout' : 'blur', onBlurOrFocusOut)
            break

          case 'focusin':
            on('focusout', onBlurOrFocusOut)
            break
        }
      })
    }

    function removeListenersFromTriggerTarget () {
      listeners.forEach(function (_ref) {
        var node = _ref.node
        var eventType = _ref.eventType
        var handler = _ref.handler
        var options = _ref.options
        node.removeEventListener(eventType, handler, options)
      })
      listeners = []
    }

    function onTrigger (event) {
      var shouldScheduleClickHide = false

      if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
        return
      }

      lastTriggerEvent = event
      currentTarget = event.currentTarget
      handleAriaExpandedAttribute()

      if (!instance.state.isVisible && isMouseEvent(event)) {
        // If scrolling, `mouseenter` events can be fired if the cursor lands
        // over a new target, but `mousemove` events don't get fired. This
        // causes interactive tooltips to get stuck open until the cursor is
        // moved
        mouseMoveListeners.forEach(function (listener) {
          return listener(event)
        })
      } // Toggle show/hide when clicking click-triggered tooltips

      if (event.type === 'click' && (!includes(instance.props.trigger, 'mouseenter') || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
        shouldScheduleClickHide = true
      } else {
        var _getNormalizedTouchSe = getNormalizedTouchSettings()
        var value = _getNormalizedTouchSe[0]
        var duration = _getNormalizedTouchSe[1]

        if (currentInput.isTouch && value === 'hold' && duration) {
          // We can hijack the show timeout here, it will be cleared by
          // `scheduleHide()` when necessary
          showTimeout = setTimeout(function () {
            scheduleShow(event)
          }, duration)
        } else {
          scheduleShow(event)
        }
      }

      if (event.type === 'click') {
        isVisibleFromClick = !shouldScheduleClickHide
      }

      if (shouldScheduleClickHide) {
        scheduleHide(event)
      }
    }

    function onMouseMove (event) {
      var isCursorOverReferenceOrPopper = closestCallback(event.target, function (el) {
        return el === reference || el === popper
      })

      if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
        return
      }

      var popperTreeData = arrayFrom(popper.querySelectorAll(POPPER_SELECTOR)).concat(popper).map(function (popper) {
        var instance = popper._tippy
        var tooltip = instance.popperChildren.tooltip
        var interactiveBorder = instance.props.interactiveBorder
        return {
          popperRect: popper.getBoundingClientRect(),
          tooltipRect: tooltip.getBoundingClientRect(),
          interactiveBorder: interactiveBorder
        }
      })

      if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
        cleanupInteractiveMouseListeners()
        scheduleHide(event)
      }
    }

    function onMouseLeave (event) {
      if (isEventListenerStopped(event)) {
        return
      }

      if (includes(instance.props.trigger, 'click') && isVisibleFromClick) {
        return
      }

      if (instance.props.interactive) {
        doc.body.addEventListener('mouseleave', scheduleHide)
        doc.addEventListener('mousemove', debouncedOnMouseMove)
        pushIfUnique(mouseMoveListeners, debouncedOnMouseMove)
        debouncedOnMouseMove(event)
        return
      }

      scheduleHide(event)
    }

    function onBlurOrFocusOut (event) {
      if (!includes(instance.props.trigger, 'focusin') && event.target !== getCurrentTarget()) {
        return
      } // If focus was moved to within the popper

      if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
        return
      }

      scheduleHide(event)
    }

    function isEventListenerStopped (event) {
      var supportsTouch = ('ontouchstart' in window)
      var isTouchEvent = includes(event.type, 'touch')
      var isCustomTouch = getIsCustomTouchBehavior()
      return supportsTouch && currentInput.isTouch && isCustomTouch && !isTouchEvent || currentInput.isTouch && !isCustomTouch && isTouchEvent
    }

    function createPopperInstance () {
      var popperOptions = instance.props.popperOptions
      var arrow = instance.popperChildren.arrow
      var flipModifier = getModifier(popperOptions, 'flip')
      var preventOverflowModifier = getModifier(popperOptions, 'preventOverflow')
      var distancePx

      function applyMutations (data) {
        var prevPlacement = instance.state.currentPlacement
        instance.state.currentPlacement = data.placement

        if (instance.props.flip && !instance.props.flipOnUpdate) {
          if (data.flipped) {
            instance.popperInstance.options.placement = data.placement
          }

          setModifierValue(instance.popperInstance.modifiers, 'flip', 'enabled', false)
        }

        tooltip.setAttribute('data-placement', data.placement)

        if (data.attributes['x-out-of-boundaries'] !== false) {
          tooltip.setAttribute('data-out-of-boundaries', '')
        } else {
          tooltip.removeAttribute('data-out-of-boundaries')
        }

        var basePlacement = getBasePlacement(data.placement)
        var isVerticalPlacement = includes(['top', 'bottom'], basePlacement)
        var isSecondaryPlacement = includes(['bottom', 'right'], basePlacement) // Apply `distance` prop

        tooltip.style.top = '0'
        tooltip.style.left = '0'
        tooltip.style[isVerticalPlacement ? 'top' : 'left'] = (isSecondaryPlacement ? 1 : -1) * distancePx + 'px' // Careful not to cause an infinite loop here
        // Fixes https://github.com/FezVrasta/popper.js/issues/784

        if (prevPlacement && prevPlacement !== data.placement) {
          instance.popperInstance.update()
        }
      }

      var config = _extends$1({
        eventsEnabled: false,
        placement: instance.props.placement
      }, popperOptions, {
        modifiers: _extends$1({}, popperOptions && popperOptions.modifiers, {
          // We can't use `padding` on the popper el because of these bugs when
          // flipping from a vertical to horizontal placement or vice-versa,
          // there is severe flickering.
          // https://github.com/FezVrasta/popper.js/issues/720
          // This workaround increases bundle size by 250B minzip unfortunately,
          // due to need to custom compute the distance (since Popper rect does
          // not get affected by the inner tooltip's distance offset)
          tippyDistance: {
            enabled: true,
            order: 0,
            fn: function fn (data) {
              // `html` fontSize may change while `popperInstance` is alive
              // e.g. on resize in media queries
              distancePx = getUnitsInPx(doc, instance.props.distance)
              var basePlacement = getBasePlacement(data.placement)
              var computedPreventOverflowPadding = getComputedPadding(basePlacement, preventOverflowModifier && preventOverflowModifier.padding, distancePx)
              var computedFlipPadding = getComputedPadding(basePlacement, flipModifier && flipModifier.padding, distancePx)
              var instanceModifiers = instance.popperInstance.modifiers
              setModifierValue(instanceModifiers, 'preventOverflow', 'padding', computedPreventOverflowPadding)
              setModifierValue(instanceModifiers, 'flip', 'padding', computedFlipPadding)
              return data
            }
          },
          preventOverflow: _extends$1({
            boundariesElement: instance.props.boundary
          }, preventOverflowModifier),
          flip: _extends$1({
            enabled: instance.props.flip,
            behavior: instance.props.flipBehavior
          }, flipModifier),
          arrow: _extends$1({
            element: arrow,
            enabled: !!arrow
          }, getModifier(popperOptions, 'arrow')),
          offset: _extends$1({
            offset: instance.props.offset
          }, getModifier(popperOptions, 'offset'))
        }),
        onCreate: function onCreate (data) {
          applyMutations(data)
          preserveInvocation(popperOptions && popperOptions.onCreate, config.onCreate, [data])
          runMountCallback()
        },
        onUpdate: function onUpdate (data) {
          applyMutations(data)
          preserveInvocation(popperOptions && popperOptions.onUpdate, config.onUpdate, [data])
          runMountCallback()
        }
      })

      instance.popperInstance = new Popper(reference, popper, config)
    }

    function runMountCallback () {
      // Only invoke currentMountCallback after 2 updates
      // This fixes some bugs in Popper.js (TODO: aim for only 1 update)
      if (popperUpdates === 0) {
        popperUpdates++ // 1

        instance.popperInstance.update()
      } else if (currentMountCallback && popperUpdates === 1) {
        popperUpdates++ // 2

        reflow(popper)
        currentMountCallback()
      }
    }

    function mount () {
      // The mounting callback (`currentMountCallback`) is only run due to a
      // popperInstance update/create
      popperUpdates = 0
      var appendTo = instance.props.appendTo
      var parentNode // By default, we'll append the popper to the triggerTargets's parentNode so
      // it's directly after the reference element so the elements inside the
      // tippy can be tabbed to
      // If there are clipping issues, the user can specify a different appendTo
      // and ensure focus management is handled correctly manually

      var node = getCurrentTarget()

      if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
        parentNode = node.parentNode
      } else {
        parentNode = invokeWithArgsOrReturn(appendTo, [node])
      } // The popper element needs to exist on the DOM before its position can be
      // updated as Popper.js needs to read its dimensions

      if (!parentNode.contains(popper)) {
        parentNode.appendChild(popper)
      }

      setModifierValue(instance.popperInstance.modifiers, 'flip', 'enabled', instance.props.flip)
      instance.popperInstance.enableEventListeners() // Mounting callback invoked in `onUpdate`

      instance.popperInstance.update()
    }

    function scheduleShow (event) {
      instance.clearDelayTimeouts()

      if (!instance.popperInstance) {
        createPopperInstance()
      }

      if (event) {
        invokeHook('onTrigger', [instance, event])
      }

      addDocumentMouseDownListener()
      var delay = getDelay(true)

      if (delay) {
        showTimeout = setTimeout(function () {
          instance.show()
        }, delay)
      } else {
        instance.show()
      }
    }

    function scheduleHide (event) {
      instance.clearDelayTimeouts()
      invokeHook('onUntrigger', [instance, event])

      if (!instance.state.isVisible) {
        removeDocumentMouseDownListener()
        return
      } // For interactive tippies, scheduleHide is added to a document.body handler
      // from onMouseLeave so must intercept scheduled hides from mousemove/leave
      // events when trigger contains mouseenter and click, and the tip is
      // currently shown as a result of a click.

      if (includes(instance.props.trigger, 'mouseenter') && includes(instance.props.trigger, 'click') && includes(['mouseleave', 'mousemove'], event.type) && isVisibleFromClick) {
        return
      }

      var delay = getDelay(false)

      if (delay) {
        hideTimeout = setTimeout(function () {
          if (instance.state.isVisible) {
            instance.hide()
          }
        }, delay)
      } else {
        // Fixes a `transitionend` problem when it fires 1 frame too
        // late sometimes, we don't want hide() to be called.
        scheduleHideAnimationFrame = requestAnimationFrame(function () {
          instance.hide()
        })
      }
    }
    /* ======================= 🔑 Public methods 🔑 ======================= */

    function enable () {
      instance.state.isEnabled = true
    }

    function disable () {
      // Disabling the instance should also hide it
      // https://github.com/atomiks/tippy.js-react/issues/106
      instance.hide()
      instance.state.isEnabled = false
    }

    function clearDelayTimeouts () {
      clearTimeout(showTimeout)
      clearTimeout(hideTimeout)
      cancelAnimationFrame(scheduleHideAnimationFrame)
    }

    function setProps (partialProps) {
      if (instance.state.isDestroyed) {
        return
      }

      invokeHook('onBeforeUpdate', [instance, partialProps])
      removeListenersFromTriggerTarget()
      var prevProps = instance.props
      var nextProps = evaluateProps(reference, _extends$1({}, instance.props, {}, partialProps, {
        ignoreAttributes: true
      }))
      nextProps.ignoreAttributes = useIfDefined(partialProps.ignoreAttributes, prevProps.ignoreAttributes)
      instance.props = nextProps
      addListenersToTriggerTarget()

      if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
        cleanupInteractiveMouseListeners()
        debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce)
      }

      updatePopperElement(popper, prevProps, nextProps)
      instance.popperChildren = getChildren(popper) // Ensure stale aria-expanded attributes are removed

      if (prevProps.triggerTarget && !nextProps.triggerTarget) {
        normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
          node.removeAttribute('aria-expanded')
        })
      } else if (nextProps.triggerTarget) {
        reference.removeAttribute('aria-expanded')
      }

      handleAriaExpandedAttribute()

      if (instance.popperInstance) {
        if (POPPER_INSTANCE_DEPENDENCIES.some(function (prop) {
          return hasOwnProperty(partialProps, prop) && partialProps[prop] !== prevProps[prop]
        })) {
          var currentReference = instance.popperInstance.reference
          instance.popperInstance.destroy()
          createPopperInstance()
          instance.popperInstance.reference = currentReference

          if (instance.state.isVisible) {
            instance.popperInstance.enableEventListeners()
          }
        } else {
          instance.popperInstance.update()
        }
      }

      invokeHook('onAfterUpdate', [instance, partialProps])
    }

    function setContent (content) {
      instance.setProps({
        content: content
      })
    }

    function show (duration) {
      if (duration === void 0) {
        duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration)
      }

      var isAlreadyVisible = instance.state.isVisible
      var isDestroyed = instance.state.isDestroyed
      var isDisabled = !instance.state.isEnabled
      var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch

      if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
        return
      } // Normalize `disabled` behavior across browsers.
      // Firefox allows events on disabled elements, but Chrome doesn't.
      // Using a wrapper element (i.e. <span>) is recommended.

      if (getCurrentTarget().hasAttribute('disabled')) {
        return
      }

      if (!instance.popperInstance) {
        createPopperInstance()
      }

      invokeHook('onShow', [instance], false)

      if (instance.props.onShow(instance) === false) {
        return
      }

      addDocumentMouseDownListener()
      popper.style.visibility = 'visible'
      instance.state.isVisible = true // Prevent a transition of the popper from its previous position and of the
      // elements at a different placement
      // Check if the tippy was fully unmounted before `show()` was called, to
      // allow for smooth transition for `createSingleton()`

      if (!instance.state.isMounted) {
        setTransitionDuration(transitionableElements.concat(popper), 0)
      }

      currentMountCallback = function currentMountCallback () {
        if (!instance.state.isVisible) {
          return
        }

        setTransitionDuration([popper], instance.props.updateDuration)
        setTransitionDuration(transitionableElements, duration)
        setVisibilityState(transitionableElements, 'visible')
        handleAriaDescribedByAttribute()
        handleAriaExpandedAttribute()
        pushIfUnique(mountedInstances, instance)
        updateIOSClass(true)
        instance.state.isMounted = true
        invokeHook('onMount', [instance])
        onTransitionedIn(duration, function () {
          instance.state.isShown = true
          invokeHook('onShown', [instance])
        })
      }

      mount()
    }

    function hide (duration) {
      if (duration === void 0) {
        duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration)
      }

      var isAlreadyHidden = !instance.state.isVisible && !isBeingDestroyed
      var isDestroyed = instance.state.isDestroyed
      var isDisabled = !instance.state.isEnabled && !isBeingDestroyed

      if (isAlreadyHidden || isDestroyed || isDisabled) {
        return
      }

      invokeHook('onHide', [instance], false)

      if (instance.props.onHide(instance) === false && !isBeingDestroyed) {
        return
      }

      removeDocumentMouseDownListener()
      popper.style.visibility = 'hidden'
      instance.state.isVisible = false
      instance.state.isShown = false
      setTransitionDuration(transitionableElements, duration)
      setVisibilityState(transitionableElements, 'hidden')
      handleAriaDescribedByAttribute()
      handleAriaExpandedAttribute()
      onTransitionedOut(duration, function () {
        instance.popperInstance.disableEventListeners()
        instance.popperInstance.options.placement = instance.props.placement
        popper.parentNode.removeChild(popper)
        mountedInstances = mountedInstances.filter(function (i) {
          return i !== instance
        })

        if (mountedInstances.length === 0) {
          updateIOSClass(false)
        }

        instance.state.isMounted = false
        invokeHook('onHidden', [instance])
      })
    }

    function destroy () {
      if (instance.state.isDestroyed) {
        return
      }

      isBeingDestroyed = true
      instance.clearDelayTimeouts()
      instance.hide(0)
      removeListenersFromTriggerTarget()
      delete reference._tippy

      if (instance.popperInstance) {
        instance.popperInstance.destroy()
      }

      isBeingDestroyed = false
      instance.state.isDestroyed = true
      invokeHook('onDestroy', [instance])
    }
  }

  function tippy (targets, optionalProps,
  /** @deprecated use Props.plugins */
    plugins) {
    if (optionalProps === void 0) {
      optionalProps = {}
    }

    if (plugins === void 0) {
      plugins = []
    }

    plugins = defaultProps.plugins.concat(optionalProps.plugins || plugins)

    bindGlobalEventListeners()

    var passedProps = _extends$1({}, optionalProps, {
      plugins: plugins
    })

    var elements = getArrayOfElements(targets)

    var instances = elements.reduce(function (acc, reference) {
      var instance = reference && createTippy(reference, passedProps)

      if (instance) {
        acc.push(instance)
      }

      return acc
    }, [])
    return isElement(targets) ? instances[0] : instances
  }

  tippy.version = version
  tippy.defaultProps = defaultProps
  tippy.setDefaultProps = setDefaultProps
  tippy.currentInput = currentInput

  var cache = new Map()
  var plugin = {
    name: 'remote',
    defaultValue: false,
    fn: function fn (instance) {
      var state = instance.state
      return {
        onCreate: function onCreate () {
          state.isLoading = false
          state.isLoaded = false
        },
        onTrigger: function onTrigger () {
          if (state.isLoaded || state.isLoading) return
          var src = instance.props.remote
          if (!src) return

          var _ref = cache.get(src) || {}
          var content = _ref.content

          if (content) {
            instance.setContent(content)
            return
          }

          state.isLoading = true
          fetch(src, {
            credentials: 'same-origin'
          }).then(function (response) {
            return response.text()
          }).then(function (content) {
            instance.setContent(content)
            state.isLoaded = true
            cache.set(src, {
              content: content
            })
          }).catch(function () {
            state.isLoaded = false
          }).finally(function () {
            state.isLoading = false
          })
        },
        onDestroy: function onDestroy () {
          cache.delete(instance.props.remote)
        }
      }
    }
  }

  tippy('[data-tippy-remote]', {
    flipOnUpdate: true,
    interactive: true,
    plugins: [plugin],
    theme: 'light-border'
  })
}())
